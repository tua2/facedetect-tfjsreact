{"version":3,"sources":["utilities.js","CocoDetection.js","App.js","index.js"],"names":["drawRectCOCOModel","detections","ctx","forEach","prediction","x","y","width","height","text","color","Math","floor","random","toString","strokeStyle","font","beginPath","fillStyle","fillText","round","lineWidth","rect","stroke","CocoDetection","onLoad","onFinishLoad","webcamRef","useRef","canvasRef","runCoco","useCallback","console","log","cocossd","net","setInterval","detect","current","video","readyState","videoWidth","videoHeight","obj","getContext","useEffect","style","position","minHeight","ref","muted","marginLeft","marginRight","textAlign","left","right","top","zindex","App","useState","camera","showCamera","loadTitle","setLoadTitle","className","display","justifyContent","backgroundColor","bottom","padding","borderRadius","cursor","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"yYA0CaA,EAAoB,SAACC,EAAYC,GAE1CD,EAAWE,SAAQ,SAAAC,GAGf,kBAA8BA,EAAiB,KAAC,GAAzCC,EAAC,KAAEC,EAAC,KAAEC,EAAK,KAAEC,EAAM,KACpBC,EAAOL,EAAkB,MAIzBM,EAAQC,KAAKC,MAAoB,SAAdD,KAAKE,UAAmBC,SAAS,IAC1DZ,EAAIa,YAAc,IAAML,EACxBR,EAAIc,KAAO,aAGXd,EAAIe,YACJf,EAAIgB,UAAY,IAAMR,EACtBR,EAAIiB,SAASV,EAAO,IAAME,KAAKS,MAA0B,IAApBhB,EAAkB,OAAS,IAAKC,EAAGC,EAAE,IAC1EJ,EAAImB,UAAY,EAChBnB,EAAIoB,KAAKjB,EAAGC,EAAGC,EAAOC,GACtBN,EAAIqB,QACR,GACJ,E,QCIeC,MA/Df,SAAuB,GAAyB,IAAxBC,EAAM,EAANA,OAAQC,EAAY,EAAZA,aACtBC,EAAYC,iBAAO,MACnBC,EAAYD,iBAAO,MAGnBE,EAAUC,sBAAW,gCAAC,8FAGI,OAF5BN,EAAO,iCAEPO,QAAQC,IAAI,iBAAgB,SACVC,SAAe,KAAD,EAA1BC,EAAG,OACTH,QAAQC,IAAIE,GACZH,QAAQC,IAAI,0BAGZG,aAAY,WACRC,EAAOF,EACX,GAAG,IAAI,2CACR,IAEGE,EAAM,iDAAG,WAAOF,GAAG,8FAEa,qBAAtBR,EAAUW,SAAiD,OAAtBX,EAAUW,SAA2D,IAAvCX,EAAUW,QAAQC,MAAMC,WAAgB,iBAcvH,OAZMD,EAAQZ,EAAUW,QAAQC,MAC1BE,EAAad,EAAUW,QAAQC,MAAME,WACrCC,EAAcf,EAAUW,QAAQC,MAAMG,YAG5Cf,EAAUW,QAAQC,MAAMhC,MAAQkC,EAChCd,EAAUW,QAAQC,MAAM/B,OAASkC,EAGjCb,EAAUS,QAAQ/B,MAAQkC,EAC1BZ,EAAUS,QAAQ9B,OAASkC,EAE3B,UACkBP,EAAIE,OAAOE,GAAO,KAAD,GAA7BI,EAAG,OACTX,QAAQC,IAAIU,GACZjB,EAAa,iEAGPxB,EAAe,OAAT2B,QAAS,IAATA,GAAkB,QAAT,EAATA,EAAWS,eAAO,WAAT,EAAT,EAAoBM,WAAW,MACvC5C,EAAkB2C,EAAKzC,GAAK,4CAEnC,gBAzBW,sCA+BZ,OAJA2C,qBAAU,WACNf,GACJ,GAAE,CAACA,IAGC,sBAAKgB,MAAO,CAACC,SAAU,WAAYxC,MAAO,OAAQyC,UAAW,SAAS,UAClE,cAAC,IAAM,CAACC,IAAKtB,EAAWuB,OAAO,EAC3BJ,MAAO,CAAEC,SAAU,WAAYI,WAAY,OAAQC,YAAa,OAAQC,UAAW,SAAUC,KAAM,EAAGC,MAAO,EAAGC,IAAK,MAAOC,OAAQ,EAAGlD,MAAO,IAAKC,OAAQ,OAE/J,wBACIyC,IAAKpB,EACLiB,MAAO,CAAEC,SAAU,WAAYI,WAAY,OAAQC,YAAa,OAAQC,UAAW,SAAUC,KAAM,EAAGC,MAAO,EAAGC,IAAK,MAAOC,OAAQ,EAAGlD,MAAO,IAAKC,OAAQ,SAI3K,E,OCdekD,MA/Cf,WACC,MAA6BC,oBAAS,GAAM,mBAArCC,EAAM,KAAEC,EAAU,KACzB,EAAoCF,mBAAS,QAAO,mBACpD,GADiB,KAAe,KACEA,mBAAS,sCAAoC,mBAAxEG,EAAS,KAAEC,EAAY,KAoB9B,OACC,sBAAKC,UAAU,MAAK,UACnB,qBAAKlB,MAAO,CAACC,SAAU,WAAYS,IAAK,GAAIjD,MAAO,OAAQ0D,QAAS,OAAQC,eAAgB,UAAU,SACrG,4BAAIJ,MAEHF,EAED,cAAC,EAAa,CAACnC,OApBG,SAAChB,GACrBsD,EAAatD,EACd,EAkBwCiB,aAhBf,SAACjB,GACzBsD,EAAatD,EACd,IAiBG,qBAAKqC,MAAO,CAACC,SAAU,WAAYI,WAAY,OAAQC,YAAa,OAAQC,UAAW,SAAUC,KAAM,EAAGC,MAAO,EAAGE,OAAQ,EAAGlD,MAAO,IAAKC,OAAQ,IAAK2D,gBAAiB,UAI1K,qBAAKrB,MAAO,CAACC,SAAU,WAAYqB,OAAQ,GAAI7D,MAAO,OAAQ0D,QAAS,OAAQC,eAAgB,UAAU,SAExG,mBAAGpB,MAAO,CAACuB,QAAS,YAAaF,gBAAiB,UAAWG,aAAc,GAAIC,OAAQ,UAAWpB,WAAY,IAAKqB,QArB1F,WAC3BX,GAAYD,GACZG,EAAa,oCACd,EAkBmJ,SAC9IH,EAAQ,iBAAmB,wBAKjC,EC7CAa,IAASC,OACL,cAAC,IAAMC,WAAU,UACb,cAAC,EAAG,MAERC,SAASC,eAAe,Q","file":"static/js/main.cb03a15a.chunk.js","sourcesContent":["//Js\nconst labelMap = {\n    1: {\n        name:'Car', color:'lime'\n    },\n    2: {\n        name:'Handphone', color:'yellow'\n    }\n}\n\n// Main drawing function\nexport const drawRectCustomModel = (boxes, classes, scores, threshold, imgWidth, imgHeight, ctx) =>{\n\n\t// Loop through each prediction\n\tfor(let i=0; i <= boxes.length; i++){\n\t\t// Check if prediction is valid\n\t\tif(boxes[i] && classes[i] && scores[i]>threshold){\n\t\t\n\t\t\t// Exrtract boxes and classes\n\t\t\tconst [y, x, height, width] = boxes[i]; \n\t\t\tconst text = classes[i];\n\n\t\t\tconsole.log(width, height, labelMap[text]['name'] + ' ' + Math.round(scores[i]*100) + '%')\n\t\t\t\n\t\t\t// Setup canvas styles\n\t\t\t// const color = Math.floor(Math.random()*16777215).toString(16);\n\t\t\tctx.beginPath();\n\t\t\tctx.strokeStyle = labelMap[text]['color']\n\t\t\tctx.font = '20px Arial';\n\t\t\tctx.fillStyle = labelMap[text]['color']\n\t\t\tctx.lineWidth = 5\n\n\t\t\t// Draw text and rectangle \n\t\t\tctx.fillText(labelMap[text]['name'] + ' ' + Math.round(scores[i]*100) + '%', x*imgWidth, y*imgHeight-5);\n\t\t\tctx.rect(x*imgWidth, y*imgHeight, width*imgWidth/2, height*imgWidth/2);    \n\t\t\tctx.stroke();  \n\t\t}\n\t}\n}\n\n\n\nexport const drawRectCOCOModel = (detections, ctx) =>{\n    // Loop through each prediction\n    detections.forEach(prediction => {\n  \n        // Extract boxes and classes\n        const [x, y, width, height] = prediction['bbox']; \n        const text = prediction['class']; \n    \n        // ctx.scale(-1, 1);\n        // Set styling\n        const color = Math.floor(Math.random()*16777215).toString(16);\n        ctx.strokeStyle = '#' + color\n        ctx.font = '20px Arial';\n    \n        // Draw rectangles and text\n        ctx.beginPath();   \n        ctx.fillStyle = '#' + color\n        ctx.fillText(text + ' ' + Math.round(prediction['score']*100) + '%', x, y-10);\n        ctx.lineWidth = 5\n        ctx.rect(x, y, width, height); \n        ctx.stroke();\n    });\n} ","import React, { useRef, useEffect, useCallback } from \"react\";\nimport * as cocossd from \"@tensorflow-models/coco-ssd\";\nimport Webcam from \"react-webcam\";\nimport {  drawRectCOCOModel } from \"./utilities\";\n\nfunction CocoDetection({onLoad, onFinishLoad}) {\n    const webcamRef = useRef(null);\n    const canvasRef = useRef(null);\n\n    // Main function\n    const runCoco = useCallback(async () => {\n        onLoad('Loading model, please wait...')\n\n        console.log('Loading model')\n        const net = await cocossd.load();\n        console.log(net)\n        console.log(\"Handpose model loaded.\");\n\n        //  Loop and detect hands\n        setInterval(() => {\n            detect(net);\n        }, 10);\n    }, []);\n\n    const detect = async (net) => {\n        // Check data is available\n        if ( typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null && webcamRef.current.video.readyState === 4 ) {\n        // Get Video Properties\n        const video = webcamRef.current.video;\n        const videoWidth = webcamRef.current.video.videoWidth;\n        const videoHeight = webcamRef.current.video.videoHeight;\n\n        // Set video width\n        webcamRef.current.video.width = videoWidth;\n        webcamRef.current.video.height = videoHeight;\n\n        // Set canvas height and width\n        canvasRef.current.width = videoWidth;\n        canvasRef.current.height = videoHeight;\n\n        // Make Detections\n        const obj = await net.detect(video);\n        console.log(obj)\n        onFinishLoad('Finish load model, reload the page if no one detected or lag!')\n\n        // Draw mesh\n        const ctx = canvasRef?.current?.getContext(\"2d\");\n            drawRectCOCOModel(obj, ctx); \n        }\n    };\n\n    useEffect(()=>{\n        runCoco()\n    },[runCoco]);\n\n    return (\n        <div style={{position: 'relative', width: '100%', minHeight: '100vh'}}>\n            <Webcam ref={webcamRef} muted={true} /* mirrored={true} */\n                style={{ position: 'absolute', marginLeft: \"auto\", marginRight: \"auto\", textAlign: \"center\", left: 0, right: 0, top: '10%', zindex: 9, width: 640, height: 480}}\n            />\n            <canvas\n                ref={canvasRef}\n                style={{ position: 'absolute', marginLeft: \"auto\", marginRight: \"auto\", textAlign: \"center\", left: 0, right: 0, top: '10%', zindex: 8, width: 640, height: 480}}\n            />\n        </div>\n    );\n}\n\nexport default CocoDetection;\n","import React, {useState} from 'react';\nimport './App.css';\nimport CocoDetection from './CocoDetection';\nimport CustomDetection from './CustomDetection';\n\nfunction App() {\n\tconst [camera, showCamera] = useState(false)\n\tconst [detectType, setDetectType] = useState('coco')\n\tconst [loadTitle, setLoadTitle] = useState('Realtime Object Detection ReactJS')\n\n\tconst handleChangeDetection = () => {\n\t\tif(detectType === 'coco') setDetectType('custom')\n\t\telse setDetectType('coco')\n\t}\n\n\tconst handleOnLoad = (text) => {\n\t\tsetLoadTitle(text)\n\t}\n\n\tconst handleFinishLoad = (text) => {\n\t\tsetLoadTitle(text)\n\t}\n\n\tconst handleStopDetection = () => {\n\t\tshowCamera(!camera)\n\t\tsetLoadTitle('Realtime Object Detection ReactJS')\n\t}\n\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<div style={{position: 'absolute', top: 10, width: '100%', display: 'flex', justifyContent: 'center'}}>\n\t\t\t\t<p>{loadTitle}</p>\n\t\t\t</div>\n\t\t\t{ camera?\n\t\t\t\t\n\t\t\t\t<CocoDetection onLoad={handleOnLoad} onFinishLoad={handleFinishLoad} />\n\t\t\t\t\t\n\t\t\t\t:\n\t\t\t\t<div style={{position: 'absolute', marginLeft: \"auto\", marginRight: \"auto\", textAlign: \"center\", left: 0, right: 0, zindex: 9, width: 640, height: 480, backgroundColor: '#446'}}>\n\n\t\t\t\t</div>\n\t\t\t}\n\t\t\t<div style={{position: 'absolute', bottom: 10, width: '100%', display: 'flex', justifyContent: 'center'}}>\n\t\t\t\t\n\t\t\t\t<p style={{padding: '10px 25px', backgroundColor: '#7700cf', borderRadius: 10, cursor: 'pointer', marginLeft: 10}} onClick={handleStopDetection}>\n\t\t\t\t\t{camera? 'Stop Detection' : 'Start Detection'}\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n// gan"],"sourceRoot":""}